"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const clock_1 = require("./clock");
const counter_1 = require("./counter");
const counting_1 = require("./counting");
const hdr_histogram_1 = require("./hdr-histogram");
const histogram_1 = require("./histogram");
const meter_1 = require("./meter");
const metric_1 = require("./metric");
const reservoir_1 = require("./reservoir");
const timer_1 = require("./timer");
/**
 * Represents a registration of a {@link MetricRegistryListener}.
 * This instance can be used to safely remove the listener from registry again.
 *
 * @export
 * @class MetricRegistryListenerRegistration
 */
class MetricRegistryListenerRegistration {
    /**
     * Creates an instance of MetricRegistryListenerRegistration.
     *
     * @param {MetricRegistryListener} listener
     * @param {MetricRegistry} registry
     * @memberof MetricRegistryListenerRegistration
     */
    constructor(listener, registry) {
        this.listener = listener;
        this.registry = registry;
    }
    /**
     * Removes the managed listener from the metric registry.
     *
     * @returns {this}
     * @memberof MetricRegistryListenerRegistration
     */
    remove() {
        this.registry.removeListener(this.listener);
        return this;
    }
}
exports.MetricRegistryListenerRegistration = MetricRegistryListenerRegistration;
/**
 * Proxy object for a metric (one metric can be registered with multiple names e.g. in different groups).
 *
 * @export
 * @class MetricRegistration
 * @template T
 */
class MetricRegistration {
    /**
     * Creates an instance of MetricRegistration.
     *
     * @param {T} metricRef
     * @memberof MetricRegistration
     */
    constructor(metricRef) {
        this.metricRef = metricRef;
        this.name = metricRef.getName();
    }
}
exports.MetricRegistration = MetricRegistration;
/**
 * A metric registry manages metric instances.
 *
 * @export
 * @class MetricRegistry
 * @extends {BaseMetric}
 * @implements {MetricSet}
 */
class MetricRegistry extends metric_1.BaseMetric {
    constructor() {
        super(...arguments);
        /**
         * Default clock instance if no clock instance if provided.
         *
         * @private
         * @type {Clock}
         * @memberof MetricRegistry
         */
        this.defaultClock = new clock_1.StdClock();
        /**
         * A collection metric references.
         *
         * @private
         * @type {Array<MetricRegistration<Metric>>}
         * @memberof MetricRegistry
         */
        this.metrics = [];
        /**
         * The name factory to build metric names.
         *
         * @private
         * @type {NameFactory}
         * @memberof MetricRegistry
         */
        this.nameFactory = MetricRegistry.defaultNameFactory;
        /**
         * A collection of metric listeners.
         *
         * @private
         * @type {MetricRegistryListener[]}
         * @memberof MetricRegistry
         */
        this.listeners = [];
    }
    /**
     * Determines if the specified object is a {@link Counter} or references one.
     *
     * @static
     * @param {*} instance
     * @returns {instance is Counter}
     * @memberof MetricRegistry
     */
    static isCounter(instance) {
        return instance instanceof counter_1.Counter || instance.metricRef instanceof counter_1.Counter;
    }
    /**
     * Determines if the specified object is a {@link MonotoneCounter} or {@link Counter} or references one of them.
     *
     * @static
     * @param {*} instance
     * @returns {instance is MonotoneCounter}
     * @memberof MetricRegistry
     */
    static isMonotoneCounter(instance) {
        return instance instanceof counter_1.MonotoneCounter || instance.metricRef instanceof counter_1.MonotoneCounter;
    }
    /**
     * Determines if the specified object is a {@link MonotoneCounter} or references one.
     *
     * @static
     * @param {*} instance
     * @returns {instance is MonotoneCounter}
     * @memberof MetricRegistry
     */
    static isPureMonotoneCounter(instance) {
        return (instance instanceof counter_1.MonotoneCounter || instance.metricRef instanceof counter_1.MonotoneCounter) &&
            !MetricRegistry.isCounter(instance);
    }
    /**
     * Determines if the specified object is a {@link Histogram} or references one.
     *
     * @static
     * @param {*} instance
     * @returns {instance is Histogram}
     * @memberof MetricRegistry
     */
    static isHistogram(instance) {
        return instance instanceof histogram_1.Histogram || instance.metricRef instanceof histogram_1.Histogram;
    }
    /**
     * Determines if the specified object is a {@link Meter} or references one.
     *
     * @static
     * @param {*} instance
     * @returns {instance is Meter}
     * @memberof MetricRegistry
     */
    static isMeter(instance) {
        return instance instanceof meter_1.Meter || instance.metricRef instanceof meter_1.Meter;
    }
    /**
     * Determines if the specified object is a {@link Timer} or references one.
     *
     * @static
     * @param {*} instance
     * @returns {instance is Timer}
     * @memberof MetricRegistry
     */
    static isTimer(instance) {
        return instance instanceof timer_1.Timer || instance.metricRef instanceof timer_1.Timer;
    }
    /**
     * Determines if the specified object is a {@link Gauge} or references one.
     *
     * @static
     * @template T
     * @param {*} instance
     * @returns {instance is Gauge<T>}
     * @memberof MetricRegistry
     */
    static isGauge(instance) {
        const directGauge = !!instance.getValue && instance.getValue instanceof Function;
        const gaugeRegistration = !!instance.metricRef &&
            !!instance.metricRef.getValue &&
            instance.metricRef.getValue instanceof Function;
        return directGauge || gaugeRegistration;
    }
    /**
     * Determines if the specified object is a {@link MetricSet}.
     *
     * @static
     * @param {*} instance
     * @returns {instance is MetricSet}
     * @memberof MetricRegistry
     */
    static isMetricSet(instance) {
        return !!instance.getMetrics && instance.getMetrics instanceof Function;
    }
    /**
     * Standard function to generate the name for a metric.
     *
     * @private
     * @static
     * @param {string} baseName
     * @param {string} metricName
     * @param {Metric} metric
     * @returns {string}
     * @memberof MetricRegistry
     */
    static defaultNameFactory(baseName, metricName, metric) {
        return baseName + "." + metricName;
    }
    /**
     * Adds the specified listener and returns the corrsponding
     * registration object.
     *
     * @param {MetricRegistryListener} listener
     * @returns {MetricRegistryListenerRegistration}
     * @memberof MetricRegistry
     */
    addListener(listener) {
        this.listeners.push(listener);
        return new MetricRegistryListenerRegistration(listener, this);
    }
    /**
     * Removes a listener manually.
     *
     * @param {MetricRegistryListener} listener
     * @returns {this}
     * @memberof MetricRegistry
     */
    removeListener(listener) {
        const index = this.listeners.indexOf(listener);
        if (index > -1) {
            delete this.listeners[index];
        }
        return this;
    }
    /**
     * Sets the default name factory for metric instances.
     *
     * @param {NameFactory} nameFactory
     * @returns {this}
     * @memberof MetricRegistry
     */
    setNameFactory(nameFactory) {
        this.nameFactory = nameFactory;
        return this;
    }
    /**
     * Gets the default clock.
     *
     * @returns {Clock}
     * @memberof MetricRegistry
     */
    getDefaultClock() {
        return this.defaultClock;
    }
    /**
     * Sets the default clock.
     *
     * @param {Clock} defaultClock
     * @returns {this}
     * @memberof MetricRegistry
     */
    setDefaultClock(defaultClock) {
        this.defaultClock = defaultClock;
        return this;
    }
    /**
     * @deprecated since version 1.3 - use {@link getCounterList} instead
     */
    getCounters() {
        const map = new Map();
        this.metrics
            .filter(MetricRegistry.isCounter)
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * @deprecated since version 1.3 - use {@link getGaugeList} instead
     */
    getGauges() {
        const map = new Map();
        this.metrics
            .filter(MetricRegistry.isGauge)
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * @deprecated since version 1.3 - use {@link getHistogramList} instead
     */
    getHistograms() {
        const map = new Map();
        this.metrics
            .filter(MetricRegistry.isHistogram)
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * @deprecated since version 1.3 - use {@link getMeterList} instead
     */
    getMeters() {
        const map = new Map();
        this.metrics
            .filter(MetricRegistry.isMeter)
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * @deprecated since version 1.3 - use {@link getTimerList} instead
     */
    getTimers() {
        const map = new Map();
        this.metrics
            .filter(MetricRegistry.isTimer)
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * Gets the list of all managed counter instances.
     *
     * @returns {Counter[]}
     * @memberof MetricRegistry
     */
    getCounterList() {
        return this.metrics
            .filter(MetricRegistry.isCounter)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets the list of all managed monotone counter instances.
     *
     * @returns {MonotoneCounter[]}
     * @memberof MetricRegistry
     */
    getMonotoneCounterList() {
        return this.metrics
            .filter(MetricRegistry.isPureMonotoneCounter)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets the list of all managed gauge instances.
     *
     * @returns {Array<Gauge<any>>}
     * @memberof MetricRegistry
     */
    getGaugeList() {
        return this.metrics
            .filter(MetricRegistry.isGauge)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets the list of all managed histogram instances.
     *
     * @returns {Histogram[]}
     * @memberof MetricRegistry
     */
    getHistogramList() {
        return this.metrics
            .filter(MetricRegistry.isHistogram)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets the list of all managed meter instances.
     *
     * @returns {Meter[]}
     * @memberof MetricRegistry
     */
    getMeterList() {
        return this.metrics
            .filter(MetricRegistry.isMeter)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets the list of all managed timer instances.
     *
     * @returns {Timer[]}
     * @memberof MetricRegistry
     */
    getTimerList() {
        return this.metrics
            .filter(MetricRegistry.isTimer)
            .map((registration) => registration.metricRef);
    }
    /**
     * Gets a mapping of all managed metric instances regardless of the type.
     *
     * @returns {Map<string, Metric>}
     * @memberof MetricRegistry
     */
    getMetrics() {
        const map = new Map();
        this.metrics
            .forEach((registration) => map.set(registration.name, registration.metricRef));
        return map;
    }
    /**
     * Gets a list of all managed metric instances regardless of the type.
     *
     * @returns {Metric[]}
     * @memberof MetricRegistry
     */
    getMetricList() {
        return this.metrics.map((metric) => metric.metricRef);
    }
    /**
     * @deprecated since version 1.3 - use {@link getMetricsByName} instead
     */
    getMetric(name) {
        return this.getFirstByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link getCountersByName} instead
     */
    getCounter(name) {
        return this.getFirstByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link getGaugesByName} instead
     */
    getGauge(name) {
        return this.getFirstByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link getHistogramsByName} instead
     */
    getHistogram(name) {
        return this.getFirstByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link getMetersByName} instead
     */
    getMeter(name) {
        return this.getFirstByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link getTimersByName} instead
     */
    getTimer(name) {
        return this.getFirstByName(name);
    }
    /**
     * Gets all mamanged metric instance by name.
     *
     * @param {string} name
     * @returns {Metric[]}
     * @memberof MetricRegistry
     */
    getMetricsByName(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed counter instances by name.
     *
     * @param {string} name
     * @returns {Counter[]}
     * @memberof MetricRegistry
     */
    getCountersByName(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed monotone counter instances by name.
     *
     * @param {string} name
     * @returns {MonotoneCounter[]}
     * @memberof MetricRegistry
     */
    getMonotoneCountersByName(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed gauge instances by name.
     *
     * @param {string} name
     * @returns {Array<Gauge<any>>}
     * @memberof MetricRegistry
     */
    getGaugesByName(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed histogram instances by name.
     *
     * @param {string} name
     * @returns {Histogram[]}
     * @memberof MetricRegistry
     */
    getHistogramsByname(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed meter instances by name.
     *
     * @param {string} name
     * @returns {Meter[]}
     * @memberof MetricRegistry
     */
    getMetersByName(name) {
        return this.getByName(name);
    }
    /**
     * Gets all managed timer instances by name.
     *
     * @param {string} name
     * @returns {Timer[]}
     * @memberof MetricRegistry
     */
    getTimersByName(name) {
        return this.getByName(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeMetric(name) {
        const metrics = this.getByName(name);
        if (metrics.length > 0) {
            const index = this.metrics
                .map((m) => m.metricRef)
                .indexOf(metrics[0], 0);
            if (index > -1) {
                this.metrics.splice(index, 1);
            }
            this.fireMetricRemoved(name, metrics[0]);
        }
        return this;
    }
    /**
     * Removes all managed metric instances by name regardless of the type.
     *
     * @param {string} name
     * @returns {this}
     * @memberof MetricRegistry
     */
    removeMetrics(name) {
        const metrics = this.getByName(name);
        metrics.forEach((metric) => {
            const index = this.metrics
                .map((m) => m.metricRef)
                .indexOf(metric, 0);
            if (index > -1) {
                this.metrics.splice(index, 1);
            }
            this.fireMetricRemoved(name, metric);
        });
        return this;
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeCounter(name) {
        return this.removeMetric(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeGauge(name) {
        return this.removeMetric(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeHistogram(name) {
        return this.removeMetric(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeMeter(name) {
        return this.removeMetric(name);
    }
    /**
     * @deprecated since version 1.3 - use {@link removeMetrics} instead
     */
    removeTimer(name) {
        return this.removeMetric(name);
    }
    /**
     * Builds a new counter with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {string} [group=null]
     * @param {string} [description=null]
     * @returns {Counter}
     * @memberof MetricRegistry
     */
    newCounter(name, group = null, description = null) {
        const counter = new counter_1.Counter(name, description);
        this.registerMetric(counter, group, description);
        return counter;
    }
    /**
     * Builds a new monotone counter with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {string} [group=null]
     * @param {string} [description=null]
     * @returns {MonotoneCounter}
     * @memberof MetricRegistry
     */
    newMonotoneCounter(name, group = null, description = null) {
        const counter = new counter_1.MonotoneCounter(name, description);
        this.registerMetric(counter, group, description);
        return counter;
    }
    /**
     * Builds a new meter with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {string} [group=null]
     * @param {Clock} [clock=this.defaultClock]
     * @param {number} [sampleRate=1]
     * @param {string} [description=null]
     * @returns {Meter}
     * @memberof MetricRegistry
     */
    newMeter(name, group = null, clock = this.defaultClock, sampleRate = 1, description = null) {
        const meter = new meter_1.Meter(clock, sampleRate, name, description);
        this.registerMetric(meter, group, description);
        return meter;
    }
    /**
     * Builds a new hdr-histogram with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {number} [lowest=1] is the lowest possible number that can be recorded
     * @param {number} [max=100] is the maximum number that can be recorded
     * @param {number} [figures=3]
     *      the number of figures in a decimal number that will be maintained, must be between 1 and 5 (inclusive)
     * @param {string} [group=null]
     * @param {string} [description=null]
     * @param {Reservoir} [reservoir=null]
     * @returns {HdrHistogram}
     * @memberof MetricRegistry
     */
    newHdrHistogram(name, lowest = 1, max = 100, figures = 3, group = null, description = null, buckets = new counting_1.Buckets()) {
        const histogram = new hdr_histogram_1.HdrHistogram(lowest, max, figures, name, description, buckets);
        this.registerMetric(histogram, group, description);
        return histogram;
    }
    /**
     * Builds a new histogram with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {string} [group=null]
     * @param {string} [description=null]
     * @param {Reservoir} [reservoir=null]
     * @returns {Histogram}
     * @memberof MetricRegistry
     */
    newHistogram(name, group = null, reservoir = null, description = null, buckets = new counting_1.Buckets()) {
        if (!reservoir) {
            reservoir = new reservoir_1.SlidingWindowReservoir(1024);
        }
        const histogram = new histogram_1.Histogram(reservoir, name, description, buckets);
        this.registerMetric(histogram, group, description);
        return histogram;
    }
    /**
     * Builds a new timer with the given name and adds it
     * to the registry.
     *
     * @param {string} name
     * @param {string} [group=null]
     * @param {string} [description=null]
     * @param {Clock} [clock=this.defaultClock]
     * @param {Reservoir} [reservoir=null]
     * @returns {Timer}
     * @memberof MetricRegistry
     */
    newTimer(name, group = null, clock = this.defaultClock, reservoir = null, description = null, buckets = new counting_1.Buckets()) {
        if (!reservoir) {
            reservoir = new reservoir_1.SlidingWindowReservoir(1024);
        }
        const timer = new timer_1.Timer(clock, reservoir, name, description, buckets);
        this.registerMetric(timer, group, description);
        return timer;
    }
    /**
     * Registers the given metric under it's name in this registry.
     *
     * If the metric is a metric-set the child-metrics are
     * registered using their names the name of the metric-set is set as group.
     *
     * @param {Metric} metric
     * @param {string} [group=null]
     * @returns {this}
     * @memberof MetricRegistry
     */
    registerMetric(metric, group = null, description = null) {
        if (!!group) {
            metric.setGroup(group);
        }
        if (!!description) {
            metric.setDescription(description);
        }
        if (metric instanceof meter_1.Meter ||
            metric instanceof counter_1.Counter ||
            metric instanceof counter_1.MonotoneCounter ||
            MetricRegistry.isGauge(metric) ||
            metric instanceof histogram_1.Histogram ||
            metric instanceof timer_1.Timer) {
            this.metrics.push(new MetricRegistration(metric));
            this.fireMetricAdded(metric.getName(), metric);
        }
        else if (MetricRegistry.isMetricSet(metric)) {
            metric.getMetricList().forEach((m) => {
                m.setGroup(metric.getName());
                this.registerMetric(m);
            });
        }
        return this;
    }
    /**
     * Registeres a metric by name
     *
     * @param {string} name
     * @param {Metric} metric
     * @param {string} [group=null]
     * @deprecated since version 1.5 - use {@link registerMetric} instead
     * @returns {this}
     * @memberof MetricRegistry
     */
    register(name, metric, group = null, description = null) {
        if (!!group) {
            metric.setGroup(group);
        }
        if (!!description) {
            metric.setDescription(description);
        }
        metric.setName(this.generateName(name, metric));
        if (metric instanceof meter_1.Meter ||
            metric instanceof counter_1.Counter ||
            metric instanceof counter_1.MonotoneCounter ||
            MetricRegistry.isGauge(metric) ||
            metric instanceof histogram_1.Histogram ||
            metric instanceof timer_1.Timer) {
            this.metrics.push(new MetricRegistration(metric));
            this.fireMetricAdded(name, metric);
        }
        else if (MetricRegistry.isMetricSet(metric)) {
            metric.getMetrics().forEach((m) => {
                const metricName = this.nameFactory(name, m.getName(), m);
                this.register(metricName, m);
            });
        }
        return this;
    }
    /**
     * Finds the first metric instance by name.
     *
     * @private
     * @template T
     * @param {string} name
     * @returns {T}
     * @memberof MetricRegistry
     */
    getFirstByName(name) {
        const arr = this.getByName(name);
        if (arr.length === 0) {
            return null;
        }
        return arr[0];
    }
    /**
     * Gets all metric instances by name.
     *
     * @private
     * @template T
     * @param {string} name
     * @returns {T[]}
     * @memberof MetricRegistry
     */
    getByName(name) {
        return this.metrics
            .filter((metric) => metric.name === name)
            .map((metric) => metric.metricRef);
    }
    /**
     * Builds the name of the metric.
     *
     * @private
     * @param {string} name
     * @param {Metric} metric
     * @returns {string}
     * @memberof MetricRegistry
     */
    generateName(name, metric) {
        if (!!metric.getGroup()) {
            return `${metric.getGroup()}.${name}`;
        }
        return name;
    }
    /**
     * Invokes all metric listeners when a new metric was added.
     *
     * @private
     * @param {string} name
     * @param {Metric} metric
     * @memberof MetricRegistry
     */
    fireMetricAdded(name, metric) {
        this.listeners.forEach((listener) => listener.metricAdded(name, metric));
    }
    /**
     * Invokes all metric listeners when a metric was removed.
     *
     * @private
     * @param {string} name
     * @param {Metric} metric
     * @memberof MetricRegistry
     */
    fireMetricRemoved(name, metric) {
        this.listeners.forEach((listener) => listener.metricRemoved(name, metric));
    }
}
exports.MetricRegistry = MetricRegistry;
//# sourceMappingURL=metric-registry.js.map