"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const time_unit_1 = require("./time-unit");
/**
 * Calculates the moving average with an exponential alpha value.
 *
 * @export
 * @class ExponentiallyWeightedMovingAverage
 * @implements {MovingAverage}
 */
class ExponentiallyWeightedMovingAverage {
    /**
     * Creates an instance of ExponentiallyWeightedMovingAverage.
     *
     * @param {number} alpha
     * @param {number} interval
     * @param {TimeUnit} unit
     * @memberof ExponentiallyWeightedMovingAverage
     */
    constructor(alpha, interval, unit) {
        /**
         * The sum of all values passed to the update function.
         *
         * @private
         * @type {number}
         * @memberof ExponentiallyWeightedMovingAverage
         */
        this.sum = 0;
        /**
         * The current average.
         *
         * @private
         * @type {number}
         * @memberof ExponentiallyWeightedMovingAverage
         */
        this.avg = -1.0;
        this.alpha = alpha;
        this.interval = interval;
        this.unit = unit;
        this.timeUnitInNanoseconds = unit.convertTo(interval, time_unit_1.NANOSECOND);
    }
    /**
     * Gets the alpha value.
     *
     * @returns {number}
     * @memberof ExponentiallyWeightedMovingAverage
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Gets the time unit.
     *
     * @returns {TimeUnit}
     * @memberof ExponentiallyWeightedMovingAverage
     */
    getUnit() {
        return this.unit;
    }
    /**
     * Gets the average in the specified time unit.
     *
     * @param {TimeUnit} unit
     * @returns {number}
     * @memberof ExponentiallyWeightedMovingAverage
     */
    getAverage(unit) {
        if (this.avg === -1.0) {
            return 0;
        }
        return this.avg * time_unit_1.NANOSECOND.convertTo(this.timeUnitInNanoseconds, unit);
    }
    /**
     * Adds the value to the current sum.
     *
     * @param {number} value
     * @returns {this}
     * @memberof ExponentiallyWeightedMovingAverage
     */
    update(value) {
        this.sum += value;
        return this;
    }
    /**
     * Updates the current average by multiplying the alpha value with the difference
     * of the last average and the current average.
     *
     * Averages are calculated by dividing the sum through the sampling interval.
     *
     * If the alpha value is high the last average has more weight and vice versa.
     *
     * @returns {this}
     * @memberof ExponentiallyWeightedMovingAverage
     */
    tick() {
        const sum = this.sum;
        const avg = sum / this.interval;
        this.sum -= sum;
        if (this.avg === -1.0) {
            this.avg = avg;
        }
        else {
            this.avg += this.alpha * (avg - this.avg);
        }
        return this;
    }
}
ExponentiallyWeightedMovingAverage.ALPHA_1_MINUTE_1_SECOND_SAMPLERATE = 1 - Math.exp(-(1 / 60));
ExponentiallyWeightedMovingAverage.ALPHA_1_MINUTE_5_SECOND_SAMPLERATE = 1 - Math.exp(-(5 / 60));
ExponentiallyWeightedMovingAverage.ALPHA_5_MINUTE_1_SECOND_SAMPLERATE = 1 - Math.exp(-(1 / (60 * 5)));
ExponentiallyWeightedMovingAverage.ALPHA_5_MINUTE_5_SECOND_SAMPLERATE = 1 - Math.exp(-(5 / (60 * 5)));
ExponentiallyWeightedMovingAverage.ALPHA_15_MINUTE_1_SECOND_SAMPLERATE = 1 - Math.exp(-(1 / (60 * 15)));
ExponentiallyWeightedMovingAverage.ALPHA_15_MINUTE_5_SECOND_SAMPLERATE = 1 - Math.exp(-(5 / (60 * 15)));
exports.ExponentiallyWeightedMovingAverage = ExponentiallyWeightedMovingAverage;
//# sourceMappingURL=moving-average.js.map