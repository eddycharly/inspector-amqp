"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const clock_1 = require("./clock");
const metric_1 = require("./metric");
const moving_average_1 = require("./moving-average");
const time_unit_1 = require("./time-unit");
/**
 * Standard implementation of a rate-measuring metrics.
 *
 * @export
 * @class Meter
 * @extends {BaseMetric}
 * @implements {Metered}
 */
class Meter extends metric_1.BaseMetric {
    /**
     * Creates an instance of Meter.
     *
     * @param {Clock} clock Clock to determine update events.
     * @param {number} sampleRate number of samples per seconds.
     * @param {string} [name] optional metric name.
     * @param {string} [description] optional metric description.
     * @memberof Meter
     */
    constructor(clock, sampleRate, name, description) {
        super();
        /**
         * Continuous counter incremented in the {@link Meter#mark} method.
         *
         * @private
         * @type {number}
         * @memberof Meter
         */
        this.count = 0;
        /**
         * Moving average for 1 minute.
         *
         * @private
         * @type {MovingAverage}
         * @memberof Meter
         */
        this.avg1Minute = new moving_average_1.ExponentiallyWeightedMovingAverage(Meter.AVG_1_MINUTE, 1, time_unit_1.SECOND);
        /**
         * Moving average for 5 minutes.
         *
         * @private
         * @type {MovingAverage}
         * @memberof Meter
         */
        this.avg5Minute = new moving_average_1.ExponentiallyWeightedMovingAverage(Meter.AVG_5_MINUTE, 1, time_unit_1.SECOND);
        /**
         * Moving average for 15 minutes.
         *
         * @private
         * @type {MovingAverage}
         * @memberof Meter
         */
        this.avg15Minute = new moving_average_1.ExponentiallyWeightedMovingAverage(Meter.AVG_15_MINUTE, 1, time_unit_1.SECOND);
        this.name = name;
        this.description = description;
        this.clock = clock;
        this.startTime = clock.time();
        this.lastTime = this.startTime;
        this.sampleRate = sampleRate;
        this.interval = Meter.SECOND_1_NANOS / this.sampleRate;
    }
    /**
     * Increases the counter and updates the averages.
     *
     * @param {number} value
     * @returns {this}
     * @memberof Meter
     */
    mark(value) {
        this.tickIfNeeded();
        this.count += value;
        this.avg15Minute.update(value);
        this.avg5Minute.update(value);
        this.avg1Minute.update(value);
        return this;
    }
    /**
     * Gets the number of events.
     *
     * @returns {number}
     * @memberof Meter
     */
    getCount() {
        return this.count;
    }
    /**
     * Updates the 15 minutes average if needed and returns the rate per second.
     *
     * @returns {number}
     * @memberof Meter
     */
    get15MinuteRate() {
        this.tickIfNeeded();
        return this.avg15Minute.getAverage(time_unit_1.SECOND);
    }
    /**
     * Updates the 5 minutes average if needed and returns the rate per second.
     *
     * @returns {number}
     * @memberof Meter
     */
    get5MinuteRate() {
        this.tickIfNeeded();
        return this.avg5Minute.getAverage(time_unit_1.SECOND);
    }
    /**
     * Updates the 1 minute average if needed and returns the rate per second.
     *
     * @returns {number}
     * @memberof Meter
     */
    get1MinuteRate() {
        this.tickIfNeeded();
        return this.avg1Minute.getAverage(time_unit_1.SECOND);
    }
    /**
     * Gets the mean rate : {@link Meter#count} divided through seconds passed since {@link Meter#startTime}).
     *
     * @returns {number} either 0 or the mean rate.
     * @memberof Meter
     */
    getMeanRate() {
        if (this.count === 0) {
            return 0.0;
        }
        else {
            const elapsed = clock_1.diff(this.startTime, this.clock.time());
            return this.count / elapsed * Meter.SECOND_1_NANOS;
        }
    }
    /**
     * Calls the {@link MovingAverage#tick} for each tick.
     *
     * @private
     * @param {number} ticks number of updates.
     * @memberof Meter
     */
    tick(ticks) {
        while (ticks-- > 0) {
            this.avg15Minute.tick();
            this.avg5Minute.tick();
            this.avg1Minute.tick();
        }
    }
    /**
     * Checks for if an update of the averages is needed and if so updates the {@link Meter#lastTime}.
     *
     * @private
     * @memberof Meter
     */
    tickIfNeeded() {
        const currentTime = this.clock.time();
        const age = clock_1.diff(this.lastTime, currentTime);
        if (age > this.interval) {
            this.lastTime = currentTime;
            this.tick(Math.floor(age / this.interval));
        }
    }
}
/**
 * Alpha value for 1 min within a {@link ExponentiallyWeightedMovingAverage}.
 *
 * @private
 * @static
 * @memberof Meter
 */
Meter.AVG_1_MINUTE = moving_average_1.ExponentiallyWeightedMovingAverage.ALPHA_1_MINUTE_1_SECOND_SAMPLERATE;
/**
 * Alpha value for 5 mins within a {@link ExponentiallyWeightedMovingAverage}.
 *
 * @private
 * @static
 * @memberof Meter
 */
Meter.AVG_5_MINUTE = moving_average_1.ExponentiallyWeightedMovingAverage.ALPHA_5_MINUTE_1_SECOND_SAMPLERATE;
/**
 * Alpha value for 15 mins within a {@link ExponentiallyWeightedMovingAverage}.
 *
 * @private
 * @static
 * @memberof Meter
 */
Meter.AVG_15_MINUTE = moving_average_1.ExponentiallyWeightedMovingAverage.ALPHA_15_MINUTE_1_SECOND_SAMPLERATE;
/**
 * 1 second in nanoseconds.
 *
 * @private
 * @static
 * @memberof Meter
 */
Meter.SECOND_1_NANOS = time_unit_1.SECOND.convertTo(1, time_unit_1.NANOSECOND);
exports.Meter = Meter;
//# sourceMappingURL=meter.js.map