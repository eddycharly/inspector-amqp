"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
/**
 * Contains boundaries used to mark one end of a value range.
 *
 * @export
 * @class Buckets
 */
class Buckets {
    /**
     * Creates an instance of Buckets.
     *
     * @param {number[]} [boundaries=[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]]
     * @memberof Buckets
     */
    constructor(boundaries = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]) {
        this.boundaries = boundaries;
        boundaries.sort((a, b) => a - b);
    }
    /**
     * Creates a new Buckets object with linear-distributed values.
     *
     * @static
     * @param {number} start
     * @param {number} bucketWidth
     * @param {number} count
     * @param {number} [precision=10000]
     * @returns {Buckets}
     * @memberof Buckets
     */
    static linear(start, bucketWidth, count, precision = 10000) {
        const boundaries = new Array(count);
        const buckets = new Buckets(boundaries);
        for (let i = 0; i < count; i++) {
            buckets.boundaries[i] = start;
            buckets.boundaries[i] *= precision;
            buckets.boundaries[i] = Math.floor(buckets.boundaries[i]);
            buckets.boundaries[i] /= precision;
            start += bucketWidth;
        }
        return buckets;
    }
    /**
     * Creates a new Buckets object with exponentially distributed values.
     *
     * @static
     * @param {number} initial
     * @param {number} factor
     * @param {number} count
     * @param {number} [precision=10000]
     * @returns {Buckets}
     * @memberof Buckets
     */
    static exponential(initial, factor, count, precision = 10000) {
        if (initial <= 0.0) {
            throw new Error("initial values needs to be greater than 0.0");
        }
        if (count < 1.0) {
            throw new Error("count needs to be at least 1");
        }
        if (factor <= 1.0) {
            throw new Error("factor needs to be greater than 1.0");
        }
        const boundaries = new Array(count);
        const buckets = new Buckets(boundaries);
        buckets.boundaries[0] = initial;
        for (let i = 1; i < count; i++) {
            buckets.boundaries[i] = buckets.boundaries[i - 1] * factor;
            buckets.boundaries[i] *= precision;
            buckets.boundaries[i] = Math.floor(buckets.boundaries[i]);
            buckets.boundaries[i] /= precision;
        }
        return buckets;
    }
}
exports.Buckets = Buckets;
//# sourceMappingURL=counting.js.map