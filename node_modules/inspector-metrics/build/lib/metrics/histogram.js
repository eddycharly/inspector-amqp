"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const counting_1 = require("./counting");
const int64_1 = require("./int64");
const metric_1 = require("./metric");
/**
 * Represents the distribution of values - e.g. number of logged-in users, search result count.
 *
 * @export
 * @class Histogram
 * @extends {BaseMetric}
 * @implements {Counting}
 * @implements {Metric}
 * @implements {Sampling}
 */
class Histogram extends metric_1.BaseMetric {
    /**
     * Creates an instance of Histogram.
     *
     * @param {Reservoir} reservoir the number reservoir used
     * @param {string} [name] an optional metric name
     * @param {string} [description] an optional metric description
     * @memberof Histogram
     */
    constructor(reservoir, name, description, buckets = new counting_1.Buckets()) {
        super();
        /**
         * Continuous number representing the update operations executed.
         *
         * @private
         * @type {number}
         * @memberof Histogram
         */
        this.count = 0;
        /**
         * Sum of all values.
         *
         * @private
         * @type {number}
         * @memberof Histogram
         */
        this.sum = new int64_1.Int64Wrapper();
        /**
         * Contains all countings based on {@link Histogram#buckets}.
         *
         * @private
         * @type {{ [boundary: number]: number }}
         * @memberof Histogram
         */
        this.bucketCounts = new Map();
        this.reservoir = reservoir;
        this.name = name;
        this.description = description;
        this.buckets = buckets;
        for (const boundary of this.buckets.boundaries) {
            this.bucketCounts.set(boundary, 0);
        }
    }
    /**
     * Increases the total count, updates the reservoir,
     * updates the bucket counts and adds the specified value
     * to the overall sum.
     *
     * The bucket boundaries from {@link Buckets#boundaries} represent the upper edge
     * of a value range. Each value that is below a boundary is increasing the
     * according bucket count. E.g. assume the bucket config [10, 20, 30]:
     *
     * the value 11 is increasing buckets 20 and 30
     *
     * the value -9 is increasing all buckets (10, 20 and 30)
     *
     * the value 31 is increasing none of the buckets
     *
     * @param {number} value
     * @returns {this}
     * @memberof Histogram
     */
    update(value) {
        this.count++;
        this.sum.add(value);
        for (const boundary of this.buckets.boundaries) {
            if (value < boundary) {
                this.bucketCounts.set(boundary, this.bucketCounts.get(boundary) + 1);
            }
        }
        this.reservoir.update(value);
        return this;
    }
    /**
     * Gets the snapshot of the reservoir.
     *
     * @returns {Snapshot}
     * @memberof Histogram
     */
    getSnapshot() {
        return this.reservoir.snapshot();
    }
    /**
     * Gets the count of update operations executed.
     *
     * @returns {number}
     * @memberof Histogram
     */
    getCount() {
        return this.count;
    }
    /**
     * Gets the sum of all values.
     *
     * @returns {Int64Wrapper}
     * @memberof Histogram
     */
    getSum() {
        return this.sum;
    }
    /**
     * Gets the buckets config object.
     *
     * @returns {Buckets}
     * @memberof Histogram
     */
    getBuckets() {
        return this.buckets;
    }
    /**
     * Gets the actual bucket counts.
     *
     * @returns {{ [boundary: number]: number; }}
     * @memberof Histogram
     */
    getCounts() {
        return this.bucketCounts;
    }
}
exports.Histogram = Histogram;
//# sourceMappingURL=histogram.js.map