"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const clock_1 = require("./clock");
const counting_1 = require("./counting");
const histogram_1 = require("./histogram");
const meter_1 = require("./meter");
const metric_1 = require("./metric");
const time_unit_1 = require("./time-unit");
/**
 * A convenience wrapper class for a {@link Timer} to measure durations.
 *
 * @export
 * @class StopWatch
 */
class StopWatch {
    /**
     * Creates an instance of StopWatch.
     *
     * @param {Clock} clock
     * @param {Timer} timer
     * @memberof StopWatch
     */
    constructor(clock, timer) {
        this.clock = clock;
        this.timer = timer;
    }
    /**
     * Sets the startTime variable.
     *
     * @returns {this}
     * @memberof StopWatch
     */
    start() {
        this.startTime = this.clock.time();
        return this;
    }
    /**
     * Adds the duration between the last invocation of the start function
     * and this invocation to the timer in nanoseconds.
     *
     * @returns {this}
     * @memberof StopWatch
     */
    stop() {
        this.timer.addDuration(clock_1.diff(this.startTime, this.clock.time()), time_unit_1.NANOSECOND);
        return this;
    }
}
exports.StopWatch = StopWatch;
/**
 * A Timer is a combination of a {@link Histogram} (for the duration of an event)
 * and a {@link Meter} (for the rate of events).
 *
 * @export
 * @class Timer
 * @extends {BaseMetric}
 * @implements {Metered}
 * @implements {Sampling}
 */
class Timer extends metric_1.BaseMetric {
    /**
     * Creates an instance of Timer.
     *
     * @param {Clock} clock
     * @param {Reservoir} reservoir
     * @param {string} [name]
     * @param {string} [description]
     * @param {string} [buckets=new Buckets()]
     * @memberof Timer
     */
    constructor(clock, reservoir, name, description, buckets = new counting_1.Buckets()) {
        super();
        this.clock = clock;
        this.name = name;
        this.description = description;
        this.meter = new meter_1.Meter(clock, 1, name);
        this.histogram = new histogram_1.Histogram(reservoir, name, description, buckets);
    }
    /**
     * Adds a duration manually.
     *
     * @param {number} duration
     * @param {TimeUnit} unit
     * @returns {this}
     * @memberof Timer
     */
    addDuration(duration, unit) {
        if (duration >= 0) {
            this.histogram.update(unit.convertTo(duration, time_unit_1.NANOSECOND));
            this.meter.mark(1);
        }
        return this;
    }
    /**
     * Gets a snapshot from the embedded {@link Histogram}.
     *
     * @returns {Snapshot}
     * @memberof Timer
     */
    getSnapshot() {
        return this.histogram.getSnapshot();
    }
    /**
     * Gets the count from the embedded {@link Histogram}.
     *
     * @returns {number}
     * @memberof Timer
     */
    getCount() {
        return this.histogram.getCount();
    }
    /**
     * Gets the sum from the embedded {@link Histogram}.
     *
     * @returns {Int64Wrapper}
     * @memberof Timer
     */
    getSum() {
        return this.histogram.getSum();
    }
    /**
     * Gets the average rate per second of last 15 minutes.
     *
     * @returns {number}
     * @memberof Timer
     */
    get15MinuteRate() {
        return this.meter.get15MinuteRate();
    }
    /**
     * Gets the average rate per second of last 5 minutes.
     *
     * @returns {number}
     * @memberof Timer
     */
    get5MinuteRate() {
        return this.meter.get5MinuteRate();
    }
    /**
     * Gets the average rate per second of last minute.
     *
     * @returns {number}
     * @memberof Timer
     */
    get1MinuteRate() {
        return this.meter.get1MinuteRate();
    }
    /**
     * Gets the mean rate from the embedded {@link Meter}.
     *
     * @returns {number}
     * @memberof Timer
     */
    getMeanRate() {
        return this.meter.getMeanRate();
    }
    /**
     * Gets the bucket config from the internal {@link Histogram} and therefore representing the durations.
     *
     * @returns {Buckets}
     * @memberof Timer
     */
    getBuckets() {
        return this.histogram.getBuckets();
    }
    /**
     * Gets the bucket counts from the internal {@link Histogram}.
     *
     * @returns {Map<number, number>}
     * @memberof Timer
     */
    getCounts() {
        return this.histogram.getCounts();
    }
    /**
     * Measures the duration of the passed function's invocation
     * synchronously and adds it to the pool.
     *
     * @template T
     * @returns {T}
     * @memberof Timer
     */
    time(f) {
        const startTime = this.clock.time();
        try {
            return f();
        }
        finally {
            this.addDuration(clock_1.diff(startTime, this.clock.time()), time_unit_1.NANOSECOND);
        }
    }
    /**
     * Measures the duration of the passed function's invocation
     * asynchronously and adds it to the pool.
     *
     * @template T
     * @returns {T}
     * @memberof Timer
     */
    timeAsync(f) {
        const startTime = this.clock.time();
        return f()
            .then((res) => {
            this.addDuration(clock_1.diff(startTime, this.clock.time()), time_unit_1.NANOSECOND);
            return res;
        })
            .catch((err) => {
            this.addDuration(clock_1.diff(startTime, this.clock.time()), time_unit_1.NANOSECOND);
            throw err;
        });
    }
    /**
     * Builds a new StopWatch.
     *
     * @returns {StopWatch}
     * @memberof Timer
     */
    newStopWatch() {
        return new StopWatch(this.clock, this);
    }
}
exports.Timer = Timer;
//# sourceMappingURL=timer.js.map