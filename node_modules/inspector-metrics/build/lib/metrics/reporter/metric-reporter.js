"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const time_unit_1 = require("../time-unit");
/**
 * Base-class for metric-reporter implementations.
 *
 * @export
 * @abstract
 * @class MetricReporter
 */
class MetricReporter {
    /**
     * Creates an instance of MetricReporter.
     *
     * @param {O} options
     * @param {Map<string, string>} [tags=new Map()]
     *          tags for this reporter instance - to be combined with the tags of each metric while reporting
     * @param {Clock} [clock=new StdClock()]
     *          clock used to determine the date for the reporting as well as the minimum-reporting timeout feature
     * @param {number} [minReportingTimeout=1]
     *          timeout in minutes a metric need to be included in the report without having changed
     * @memberof MetricReporter
     */
    constructor(options) {
        /**
         * {@link MetricRegistry} instances.
         *
         * @protected
         * @type {MetricRegistry[]}
         * @memberof MetricReporter
         */
        this.metricRegistries = [];
        /**
         * Keeps track of the reporting states for each metric.
         *
         * @protected
         * @type {Map<number, MetricEntry>}
         * @memberof MetricReporter
         */
        this.metricStates = new Map();
        this.options = options;
    }
    /**
     * Gets the reporter tags.
     *
     * @returns {Map<string, string>}
     * @memberof MetricReporter
     */
    getTags() {
        return this.options.tags;
    }
    /**
     * Sets the reporter tags.
     *
     * @param {Map<string, string>} tags
     * @returns {this}
     * @memberof MetricReporter
     */
    setTags(tags) {
        this.options.tags = tags;
        return this;
    }
    /**
     * Adds a new {@link MetricRegistry} to be reported.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof MetricReporter
     */
    addMetricRegistry(metricRegistry) {
        this.metricRegistries.push(metricRegistry);
        return this;
    }
    /**
     * Removes the given {@link MetricRegistry} if it was previously added.
     *
     * @param {MetricRegistry} metricRegistry
     * @returns {this}
     * @memberof MetricReporter
     */
    removeMetricRegistry(metricRegistry) {
        const index = this.metricRegistries.indexOf(metricRegistry);
        if (index > -1) {
            this.metricRegistries.splice(index, 1);
        }
        return this;
    }
    /**
     * Reports an {@link Event}.
     *
     * Implementations can choose how to process ad-hoc events, wether it's
     * queuing the events to the next call to report or sending events
     * immediately.
     *
     * Also the usual reporting process of calling {@link #beforeReport}, do the reporting
     * and call {@link #afterReport} may not be applied for ad-hoc events.
     *
     * This implementation does nothing and always resolved the specified event.
     *
     * @param {Event} event
     * @returns {Promise<TEvent>}
     * @memberof MetricReporter
     */
    reportEvent(event) {
        return __awaiter(this, void 0, void 0, function* () {
            return event;
        });
    }
    /**
     * Sends events remaining in the queue (if a queue is used in the implementation).
     *
     * @returns {Promise<void>}
     * @memberof MetricReporter
     */
    flushEvents() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    /**
     * Called be before each reporting run.
     *
     * @protected
     * @memberof MetricReporter
     */
    beforeReport(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    /**
     * Called after each reporting run.
     *
     * @protected
     * @memberof MetricReporter
     */
    afterReport(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    /**
     * Run the reporting procedures. Calls {@link #beforeReport} before each
     * {@link MetricRegistry}'s metrics are reported and {@link #afterReport}
     * afterwards.
     *
     * @protected
     * @memberof MetricReporter
     */
    report() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.metricRegistries && this.metricRegistries.length > 0) {
                const ctx = this.createOverallReportContext();
                yield this.beforeReport(ctx);
                for (const registry of this.metricRegistries) {
                    yield this.reportMetricRegistry(ctx, registry);
                }
                yield this.afterReport(ctx);
                return ctx;
            }
            return {};
        });
    }
    /**
     * Reporting function for a sinlge {@link MetricRegistry}.
     * Calls {@link #createReportingContext} for each metric type.
     * Afterwarsds calls {@link #reportMetrics} for each of the
     * registry's metrics - grouped by type.
     * And finally calls {@link #handleResults} for each of the results.
     *
     * @protected
     * @param {MetricRegistry} registry
     * @memberof MetricReporter
     */
    reportMetricRegistry(ctx, registry) {
        return __awaiter(this, void 0, void 0, function* () {
            const date = new Date(this.options.clock.time().milliseconds);
            const counterCtx = this
                .createMetricSetReportContext(ctx, registry, date, "counter");
            const gaugeCtx = this
                .createMetricSetReportContext(ctx, registry, date, "gauge");
            const histogramCtx = this
                .createMetricSetReportContext(ctx, registry, date, "histogram");
            const meterCtx = this
                .createMetricSetReportContext(ctx, registry, date, "meter");
            const timerCtx = this
                .createMetricSetReportContext(ctx, registry, date, "timer");
            counterCtx.metrics = registry.getMonotoneCounterList();
            const monotoneCounterResults = this.reportMetrics(ctx, counterCtx, (counter) => this.reportCounter(counter, counterCtx), (counter) => counter.getCount());
            counterCtx.metrics = registry.getCounterList();
            const counterResults = this.reportMetrics(ctx, counterCtx, (counter) => this.reportCounter(counter, counterCtx), (counter) => counter.getCount());
            gaugeCtx.metrics = registry.getGaugeList();
            const gaugeResults = this.reportMetrics(ctx, gaugeCtx, (gauge) => this.reportGauge(gauge, gaugeCtx), (gauge) => gauge.getValue());
            histogramCtx.metrics = registry.getHistogramList();
            const histogramResults = this.reportMetrics(ctx, histogramCtx, (histogram) => this.reportHistogram(histogram, histogramCtx), (histogram) => histogram.getCount());
            meterCtx.metrics = registry.getMeterList();
            const meterResults = this.reportMetrics(ctx, meterCtx, (meter) => this.reportMeter(meter, meterCtx), (meter) => meter.getCount());
            timerCtx.metrics = registry.getTimerList();
            const timerResults = this.reportMetrics(ctx, timerCtx, (timer) => this.reportTimer(timer, timerCtx), (timer) => timer.getCount());
            yield this.handleResults(ctx, registry, date, "counter", monotoneCounterResults);
            yield this.handleResults(ctx, registry, date, "counter", counterResults);
            yield this.handleResults(ctx, registry, date, "gauge", gaugeResults);
            yield this.handleResults(ctx, registry, date, "histogram", histogramResults);
            yield this.handleResults(ctx, registry, date, "meter", meterResults);
            yield this.handleResults(ctx, registry, date, "timer", timerResults);
        });
    }
    /**
     * Creates an OverallReportContext.
     *
     * @protected
     * @returns {OverallReportContext}
     * @memberof MetricReporter
     */
    createOverallReportContext() {
        return {};
    }
    /**
     * Creates a MetricSetReportContext with the specified arguments.
     *
     * @protected
     * @param {OverallReportContext} overallCtx
     * @param {MetricRegistry} registry
     * @param {Date} date
     * @param {MetricType} type
     * @returns {MetricSetReportContext<any>}
     * @memberof MetricReporter
     */
    createMetricSetReportContext(overallCtx, registry, date, type) {
        return {
            date,
            metrics: [],
            overallCtx,
            registry,
            type,
        };
    }
    /**
     * Filters out each metric that does not necessarily need to be reported
     * and calls the specified reporting function for the remaining.
     *
     * @protected
     * @template M type of the metric
     * @template C typed ReportingContext
     * @param {C} ctx
     * @param {(metric: M, ctx: C) => T} reportFunction
     * @param {(metric: M, ctx: C) => number} lastModifiedFunction
     * @returns {Array<ReportingResult<M, T>>}
     * @memberof MetricReporter
     */
    reportMetrics(overallCtx, ctx, reportFunction, lastModifiedFunction) {
        return ctx.metrics
            .filter((metric) => {
            const metricId = metric.id;
            return !metricId || this.hasChanged(metricId, lastModifiedFunction(metric, ctx), ctx.date.getTime());
        })
            .map((metric) => ({
            metric,
            result: reportFunction(metric, ctx),
        }))
            .filter((result) => !!result.result);
    }
    /**
     * Determines if a metric instance has changed it's value since the last check.
     * This is always true if the minimal-reporting timeout was reached.
     *
     * @private
     * @param {number} metricId
     * @param {number} lastValue
     * @param {number} date
     * @returns {boolean}
     * @memberof MetricReporter
     */
    hasChanged(metricId, lastValue, date) {
        let changed = true;
        let metricEntry = {
            lastReport: 0,
            lastValue,
        };
        if (this.metricStates.has(metricId)) {
            metricEntry = this.metricStates.get(metricId);
            changed = metricEntry.lastValue !== lastValue;
            if (!changed) {
                const minReportingTimeout = time_unit_1.MINUTE.convertTo(this.options.minReportingTimeout, time_unit_1.MILLISECOND);
                changed = metricEntry.lastReport + minReportingTimeout < date;
            }
        }
        if (changed) {
            metricEntry.lastReport = date;
            metricEntry.lastValue = lastValue;
        }
        this.metricStates.set(metricId, metricEntry);
        return changed;
    }
    /**
     * Combines the tags of this reporter instance, the specified {@link MetricRegistry}
     * and the specified taggable metric (in this order).
     *
     * @protected
     * @param {MetricRegistry} registry
     * @param {Taggable} taggable
     * @returns {Tags}
     * @memberof MetricReporter
     */
    buildTags(registry, taggable) {
        const tags = {};
        if (this.options.tags) {
            this.options.tags.forEach((tag, key) => tags[key] = tag);
        }
        if (registry && registry.getTags()) {
            registry.getTags().forEach((tag, key) => tags[key] = tag);
        }
        if (taggable.getTags()) {
            taggable.getTags().forEach((tag, key) => tags[key] = tag);
        }
        return tags;
    }
    /**
     * Checks the number and gives it back or zero (0) if it's not a number.
     *
     * @protected
     * @param {number} value
     * @returns {number}
     * @memberof MetricReporter
     */
    getNumber(value) {
        if (isNaN(value)) {
            return 0;
        }
        return value;
    }
}
exports.MetricReporter = MetricReporter;
//# sourceMappingURL=metric-reporter.js.map