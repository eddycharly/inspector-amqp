"use strict";
/* tslint:disable:no-unused-expression */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
require("source-map-support/register");
const chai = require("chai");
const mocha_typescript_1 = require("mocha-typescript");
const sinon_1 = require("sinon");
const sinonChai = require("sinon-chai");
const metrics_1 = require("../../../lib/metrics/");
chai.use(sinonChai);
const expect = chai.expect;
class MockedLogger {
    log() { }
    error() { }
    warn() { }
    info() { }
    debug() { }
    trace() { }
}
exports.MockedLogger = MockedLogger;
class MockedClock {
    time() {
        return this.currentTime;
    }
    setCurrentTime(time) {
        this.currentTime = time;
    }
}
exports.MockedClock = MockedClock;
let LoggerReporterTest = class LoggerReporterTest {
    constructor() {
        this.clock = new MockedClock();
    }
    before() {
        this.clock.setCurrentTime({
            milliseconds: 0,
            nanoseconds: 0,
        });
        this.registry = new metrics_1.MetricRegistry();
        this.logger = new MockedLogger();
        this.loggerSpy = sinon_1.spy(this.logger.info);
        this.logger.info = this.loggerSpy;
        this.scheduler = (prog, interval) => {
            this.internalCallback = prog;
            return null;
        };
        this.schedulerSpy = sinon_1.spy(this.scheduler);
        this.reporter = new metrics_1.LoggerReporter({
            clock: this.clock,
            log: this.logger,
            minReportingTimeout: 1,
            reportInterval: 1000,
            scheduler: this.schedulerSpy,
            tags: new Map(),
            unit: metrics_1.MILLISECOND,
        });
        this.registry.setDefaultClock(this.clock);
        this.reporter.addMetricRegistry(this.registry);
    }
    "remove metric-registry which was not added"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reporter.removeMetricRegistry(this.registry);
            this.reporter.removeMetricRegistry(this.registry);
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.have.been.called;
        });
    }
    "no metric-registries added"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reporter.removeMetricRegistry(this.registry);
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            if (!!this.internalCallback) {
                yield this.internalCallback();
            }
            expect(this.loggerSpy).to.not.have.been.called;
        });
    }
    "counter reporting"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newCounter("counter1");
            this.registry.newMonotoneCounter("monotone-counter1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(2);
            let logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("monotone-counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
            logMetadata = this.loggerSpy.getCall(1).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "gauge reporting"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.registerMetric(new metrics_1.SimpleGauge("gauge1"));
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("gauge1");
            expect(logMetadata.measurement_type).to.equal("gauge");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "histogram reporting"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newHistogram("histogram1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("histogram1");
            expect(logMetadata.measurement_type).to.equal("histogram");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "meter reporting"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newMeter("meter1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("meter1");
            expect(logMetadata.measurement_type).to.equal("meter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "timer reporting"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newTimer("timer1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("timer1");
            expect(logMetadata.measurement_type).to.equal("timer");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "registry tags"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newCounter("counter1");
            this.registry.setTag("application", "app");
            this.registry.setTag("mode", "dev");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
            expect(logMetadata.tags["application"]).to.equal("app");
            expect(logMetadata.tags["mode"]).to.equal("dev");
        });
    }
    "metric tags"() {
        return __awaiter(this, void 0, void 0, function* () {
            const counter = this.registry.newCounter("counter1");
            counter.setTag("application", "app");
            counter.setTag("mode", "dev");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
            expect(logMetadata.tags["application"]).to.equal("app");
            expect(logMetadata.tags["mode"]).to.equal("dev");
        });
    }
    "registry and metric tags"() {
        return __awaiter(this, void 0, void 0, function* () {
            const counter = this.registry.newCounter("counter1");
            this.registry.setTag("application", "app");
            this.registry.setTag("mode", "dev");
            counter.setTag("mode", "test");
            counter.setTag("component", "main");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
            expect(logMetadata.tags["application"]).to.equal("app");
            expect(logMetadata.tags["mode"]).to.equal("test");
            expect(logMetadata.tags["component"]).to.equal("main");
        });
    }
    "ad-hoc event reporting without starting report"() {
        return __awaiter(this, void 0, void 0, function* () {
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            const event = new metrics_1.Event("app_started", null, null, new Date(this.clock.time().milliseconds))
                .setValue(new Date());
            yield this.reporter.reportEvent(event);
            expect(this.schedulerSpy).to.not.have.been.called;
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("app_started");
            expect(logMetadata.measurement_type).to.equal("gauge");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "ad-hoc event reporting with starting reporter"() {
        return __awaiter(this, void 0, void 0, function* () {
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            const event = new metrics_1.Event("app_started", null, null, new Date(this.clock.time().milliseconds))
                .setValue(new Date());
            yield this.reporter.reportEvent(event);
            expect(this.schedulerSpy).to.have.been.called;
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("app_started");
            expect(logMetadata.measurement_type).to.equal("gauge");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
        });
    }
    "ad-hoc event reporting with event tags"() {
        return __awaiter(this, void 0, void 0, function* () {
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            const event = new metrics_1.Event("app_started", null, null, new Date(this.clock.time().milliseconds))
                .setValue(new Date())
                .setTag("mode", "test")
                .setTag("component", "main");
            yield this.reporter.reportEvent(event);
            expect(this.schedulerSpy).to.not.have.been.called;
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("app_started");
            expect(logMetadata.measurement_type).to.equal("gauge");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags["mode"]).to.equal("test");
            expect(logMetadata.tags["component"]).to.equal("main");
        });
    }
    "ad-hoc event reporting with event + reporter tags"() {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = new Map();
            tags.set("application", "app");
            tags.set("mode", "dev");
            this.reporter.setTags(tags);
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            const event = new metrics_1.Event("app_started", null, null, new Date(this.clock.time().milliseconds))
                .setValue(new Date())
                .setTag("mode", "test")
                .setTag("component", "main");
            yield this.reporter.reportEvent(event);
            expect(this.schedulerSpy).to.not.have.been.called;
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("app_started");
            expect(logMetadata.measurement_type).to.equal("gauge");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags["application"]).to.equal("app");
            expect(logMetadata.tags["mode"]).to.equal("test");
            expect(logMetadata.tags["component"]).to.equal("main");
        });
    }
    "check reporting if value has not changed"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newCounter("counter1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            // call report
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            const logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            expect(logMetadata.tags).to.not.be.null;
            // minReportingTimeout = 1 min
            this.clock.setCurrentTime({
                milliseconds: metrics_1.MINUTE.convertTo(1, metrics_1.MILLISECOND),
                nanoseconds: 0,
            });
            // call report again
            yield this.internalCallback();
            // should be same as before
            expect(this.loggerSpy.callCount).to.equal(1);
        });
    }
    "check reporting if value has not changed for longer than the minReportingTimeout"() {
        return __awaiter(this, void 0, void 0, function* () {
            this.registry.newCounter("counter1");
            expect(this.loggerSpy).to.not.have.been.called;
            expect(this.schedulerSpy).to.not.have.been.called;
            yield this.reporter.start();
            expect(this.schedulerSpy).to.have.been.called;
            // call report
            yield this.internalCallback();
            expect(this.loggerSpy.callCount).to.equal(1);
            let logMetadata = this.loggerSpy.getCall(0).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(0);
            this.clock.setCurrentTime({
                milliseconds: metrics_1.MINUTE.convertTo(1, metrics_1.MILLISECOND) - 1,
                nanoseconds: 0,
            });
            // call report again
            yield this.internalCallback();
            // should be same
            expect(this.loggerSpy.callCount).to.equal(1);
            this.clock.setCurrentTime({
                milliseconds: metrics_1.MINUTE.convertTo(1, metrics_1.MILLISECOND) + 1,
                nanoseconds: 0,
            });
            // call report again
            yield this.internalCallback();
            // should have changed
            expect(this.loggerSpy.callCount).to.equal(2);
            logMetadata = this.loggerSpy.getCall(1).args[1];
            expect(logMetadata.measurement).to.equal("counter1");
            expect(logMetadata.measurement_type).to.equal("counter");
            expect(logMetadata.timestamp.getTime()).to.equal(60001);
            this.clock.setCurrentTime({
                milliseconds: metrics_1.MINUTE.convertTo(1, metrics_1.MILLISECOND) * 2 - 1,
                nanoseconds: 0,
            });
            // call report again
            yield this.internalCallback();
            // should be same
            expect(this.loggerSpy.callCount).to.equal(2);
        });
    }
};
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "remove metric-registry which was not added", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "no metric-registries added", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "counter reporting", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "gauge reporting", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "histogram reporting", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "meter reporting", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "timer reporting", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "registry tags", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "metric tags", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "registry and metric tags", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "ad-hoc event reporting without starting report", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "ad-hoc event reporting with starting reporter", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "ad-hoc event reporting with event tags", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "ad-hoc event reporting with event + reporter tags", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "check reporting if value has not changed", null);
__decorate([
    mocha_typescript_1.test,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LoggerReporterTest.prototype, "check reporting if value has not changed for longer than the minReportingTimeout", null);
LoggerReporterTest = __decorate([
    mocha_typescript_1.suite
], LoggerReporterTest);
exports.LoggerReporterTest = LoggerReporterTest;
//# sourceMappingURL=logger-reporter-test.js.map